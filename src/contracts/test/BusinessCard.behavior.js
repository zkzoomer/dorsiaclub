/**
 * For testing the behavior characteristic to Business Cards
 */

const { BN, constants, expectEvent, expectRevert, balance } = require('@openzeppelin/test-helpers');
const { web3 } = require('@openzeppelin/test-helpers/src/setup');
const { expect } = require('chai');
const { ZERO_ADDRESS } = constants;

// Example cardName and cardProperties
const cardProperties = ['Vice President', 'twitterAccount', 'telegramAccount', 'telegramGroup', '123456789012345678', 'discordGroup', 'githubUsername', 'userWebsite.com']
const firstToken = ['Patrick BATEMAN', cardProperties];
const secondToken = ['Paul ALLEN', cardProperties];
const thirdToken = ['David VAN PATTEN', cardProperties];
const emptyUpdate = ['', ['', '', '', '', 0, '', '', '']]

// Prices for minting, updating, and oracle
const mintPrice = web3.utils.toWei('0.1', 'ether');
const belowMintPrice = web3.utils.toWei('0.099999', 'ether');
const updatePrice = web3.utils.toWei('0.05', 'ether');
const belowUpdatePrice = web3.utils.toWei('0.0499999', 'ether')
const newUpdatePrice = web3.utils.toWei('0.03', 'ether');
const belowNewUpdatePrice = web3.utils.toWei('0.02999', 'ether');
const oraclePrice = web3.utils.toWei('0.015', 'ether');

// Filler value to add to the tokenURI, would be dynamically generated by the server oracle
const oracleCallbackTokenURI = 'Ur63bgQq3VWW9XsVviDGAFwYEZVs9AFWsTd56T9xCQmf'
const altOracleCallbackTokenURI = 'UANYk2Bga9sQiqtr3Gfk1Q7Mw1pUG16GesLYstWyDzrr'

// Changes to base and default URI
const altBaseURI ='https://gateway.ipfs.io/ipfs/Qm'
const altDefaultURI = 'fAgvNCDriGM8fYjSXBdkBsZ5buDsQ65evKw7ApWviWqM'

function shouldBehaveLikeBusinessCard (baseURI, defaultURI, owner, oracle, altOracle, buyer1, buyer2, buyer3, approved, operator) {
    // Starting point: contract deployed with name, symbol, baseURI and defaultURI set
    // Oracle not set and sale not started

    context('with unitiated oracle', function () {
        let logs = null;

        it('cannot get card', async function () {
            await expectRevert.unspecified(
                this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: mintPrice})
            )
        })

        it('cannot start sale', async function () {
            await expectRevert.unspecified( 
                this.token.startSale({ from: owner }),  
            )
        })

        it('non-owner cannot set the oracle', async function () {
            await expectRevert.unspecified(
                this.token.setOracle(oracle, { from: oracle }),
            )
        })

        it('cannot mint', async function () {
            await expectRevert.unspecified(
                this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: mintPrice })
            )
        })
    }) 
    

    context('with sale started', function () {

        beforeEach(async function () {
            // Sets up the oracle and starts the sale
            await this.token.setOracle(oracle);
            await this.token.startSale(); 
        })


        describe('tokenId', function () {
            it('starts the supply at zero', async function () {
                expect(await this.token.totalSupply()).to.be.bignumber.equal('0');
            })

            context('when minting tokens',  function() {
                beforeEach(async function () {
                    await this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: mintPrice});
                    await this.token.getCard(secondToken[0], secondToken[1], { from: buyer2, value: mintPrice});
                    await this.token.getCard(thirdToken[0], thirdToken[1], { from: buyer3, value: mintPrice});
                })

                it('increases the supply', async function() {
                    expect(await this.token.totalSupply()).to.be.bignumber.equal('3');
                })

                it('generates tokenId increasingly', async function() {
                    expect(await this.token.ownerOf(new BN('1'))).to.be.equal(buyer1);
                    expect(await this.token.ownerOf(new BN('2'))).to.be.equal(buyer2);
                    expect(await this.token.ownerOf(new BN('3'))).to.be.equal(buyer3);
                })

                it('cannot retrieve non-existing tokenIds', async function () {
                    await expectRevert(
                        this.token.ownerOf(new BN('4')),
                        "ERC721: owner query for nonexistent token"
                    )
                })
            })

            // TODO: include this on tests
            /* context('when all tokens are minted', function() {
                // To test the maximum supply more rapidly, we are assuming a maxSupply set at 5 just for testing purposes
                beforeEach(async function () {
                    await this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: mintPrice});
                    await this.token.getCard(secondToken[0], secondToken[1], { from: buyer2, value: mintPrice});
                    await this.token.getCard(thirdToken[0], thirdToken[1], { from: buyer3, value: mintPrice});
                    await this.token.getCard(fourthToken[0], fourthToken[1], { from: buyer1, value: mintPrice});
                    await this.token.getCard(fifthToken[0], fifthToken[1], { from: buyer1, value: mintPrice});
                })

                it('ends the sale, cannot mint more', async function() {
                    await expectRevert(
                        this.token.getCard(sixthToken[0], sixthToken[1], { from: buyer1, value: mintPrice}),
                        "Sale has ended"
                    )
                })
            }) */
        })


        describe('setOracle', function () {

            it('cannot change the oracle to the empty address', async function() {
                await expectRevert.unspecified(
                    this.token.setOracle(ZERO_ADDRESS, { from: oracle })
                )
            })

            context('when updating tokens', function () {
                beforeEach(async function () {
                    // minting a token to generate the update request for the oracle to act
                    await this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: mintPrice});
                    // setting up new oracle
                    await this.token.setOracle(altOracle, { from: owner });
                })
            
                it('previous oracle cannot update tokens', async function () {
                    // performing a callback
                    await expectRevert.unspecified(
                        this.token.callback(new BN('1'), oracleCallbackTokenURI, { from: oracle })
                    )
                })

                it('new oracle can update tokens', async function () {
                    await this.token.callback(new BN('1'), oracleCallbackTokenURI, { from: altOracle });
                    // now when retrieving the tokenURI, it should be equal to baseURI + oracleCallbackTokenURI
                    expect(await this.token.tokenURI(new BN('1'))).to.be.equal(baseURI + oracleCallbackTokenURI);
                })
            })
        })


        describe('modifyUpdatePrice', function () {
            context('without changing update price', function () {
                it('cannot be set below the oracle update price', async function () {
                    await expectRevert.unspecified(
                        this.token.modifyUpdatePrice(web3.utils.toWei('0.001', 'ether'), { from: owner })
                    )
                })

                it('cannot be called by non-owner', async function () {
                    await expectRevert(
                        this.token.modifyUpdatePrice(web3.utils.toWei('0.001', 'ether'), { from: oracle })
                        ,
                        "Ownable: caller is not the owner"
                    )
                })
    
            })

            context('after modifying it', function () {
                beforeEach(async function () {
                    await this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: mintPrice});
                    await this.token.modifyUpdatePrice(newUpdatePrice, { from: owner })
                })

                it('updating costs the new amount', async function () {
                    await expectRevert.unspecified(
                        this.token.updateCard(new BN('1'), secondToken[0], secondToken[1], { from: buyer1, value: oraclePrice})
                    )
                    expect(await this.token._updatePrice()).to.be.bignumber.equal(newUpdatePrice)
                    // First clear the pending update request
                    await this.token.callback(new BN('1'), oracleCallbackTokenURI, { from: oracle });
                    // Now can change without problem
                    await this.token.updateCard(new BN('1'), secondToken[0], secondToken[1], { from: buyer1, value: newUpdatePrice})
                })

                it('can be changed back to original price', async function () {
                    await this.token.modifyUpdatePrice(updatePrice, { from: owner })
                    expect(await this.token._updatePrice()).to.be.bignumber.equal(updatePrice)
                })
            })
        })


        describe('callback', function () {
            beforeEach(async function () {
                // mints a card to be updated
                await this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: mintPrice});
            })

            it('cannot be called on non requested updates', async function () {
                await expectRevert.unspecified(
                    this.token.callback(new BN('2'), oracleCallbackTokenURI, { from: oracle })
                )
            })

            it('changes the tokenURI', async function () {
                await this.token.callback(new BN('1'), oracleCallbackTokenURI, { from: oracle });
                // now when retrieving the tokenURI, it should be equal to baseURI + oracleCallbackTokenURI
                expect(await this.token.tokenURI(new BN('1'))).to.be.equal(baseURI + oracleCallbackTokenURI);
            })

            context('once updated', function () {
                beforeEach(async function () {
                    tx = await this.token.callback(new BN('1'), oracleCallbackTokenURI, { from: oracle })
                })

                it('removes the request associated with the tokenId', async function () {
                    expect(await this.token.requests(new BN('1'))).to.be.false
                })

                it('emits a TokenURIUpdated event', async function () {
                    expectEvent(tx, 'TokenURIUpdated', { tokenId: new BN('1'), tokenURI: oracleCallbackTokenURI });
                })
            })
        })


        describe('getCard', function () {
            it('cannot mint if sale is paused', async function () {
                this.token.pauseSale({ from: owner })
                await expectRevert.unspecified(
                    this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: mintPrice })
                )
            })

            it('does not mint if value is below the price', async function () {
                await expectRevert.unspecified(
                    this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: belowMintPrice })
                )
            })
            
            it('increases the token supply by one', async function () {
                let startSupply = await this.token.totalSupply()
                await this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: mintPrice })
                expect((await this.token.totalSupply()).toString()).to.be.equal((parseInt(startSupply) + 1).toString())
            })

            it('does not accept non valid characters for both name and/or position', async function () {
                await expectRevert(
                    this.token.getCard('~', firstToken[1], { from: buyer1, value: mintPrice })
                    ,
                    "Non valid characters"
                )
                await expectRevert(
                    this.token.getCard(firstToken[0], ['~', '', '', '', 0, '', '', ''], { from: buyer1, value: mintPrice })
                    ,
                    "Non valid characters"
                )
            })

            it('does not accept empty strings for both name and position', async function () {
                await expectRevert(
                    this.token.getCard('', firstToken[1], { from: buyer1, value: mintPrice })
                    ,
                    "Name taken or not valid"
                )
                await expectRevert(
                    this.token.getCard('', ['', '', '', '', 0, '', '', ''], { from: buyer1, value: mintPrice })
                    ,
                    "Name taken or not valid"
                )
                await expectRevert(
                    this.token.getCard(firstToken[0], ['', '', '', '', 0, '', '', ''], { from: buyer1, value: mintPrice })
                    ,
                    "Position not valid"
                )
            })

            it('does not accept leading/trailing space in name and/or position', async function () {
                await expectRevert(
                    this.token.getCard(' ' + firstToken[0], firstToken[1], { from: buyer1, value: mintPrice })
                    ,
                    "Name taken or not valid"
                )
                await expectRevert(
                    this.token.getCard(firstToken[0] + ' ', firstToken[1], { from: buyer1, value: mintPrice })
                    ,
                    "Name taken or not valid"
                )
                await expectRevert(
                    this.token.getCard(' ' + firstToken[0]+ ' ', firstToken[1], { from: buyer1, value: mintPrice })
                    ,
                    "Name taken or not valid"
                )
                await expectRevert(
                    this.token.getCard(firstToken[0], [' Vice President', '', '', '', 0, '', '', ''], { from: buyer1, value: mintPrice })
                    ,
                    "Position not valid"
                )
                await expectRevert(
                    this.token.getCard(firstToken[0], ['Vice President ', '', '', '', 0, '', '', ''], { from: buyer1, value: mintPrice })
                    ,
                    "Position not valid"
                )
                await expectRevert(
                    this.token.getCard(firstToken[0], [' Vice President ', '', '', '', 0, '', '', ''], { from: buyer1, value: mintPrice })
                    ,
                    "Position not valid"
                )
            })

            it('accepts names with more than one space', async function () {
                this.token.getCard('filler filler filler', firstToken[1], { from: buyer1, value: mintPrice })
            })

            it('does not accept names of more than 22 characters', async function () {
                this.token.getCard('hasexactlytwentytwocha', firstToken[1], { from: buyer1, value: mintPrice })
                await expectRevert(
                    this.token.getCard('hasmorethantwentytwocha', secondToken[1], { from: buyer1, value: mintPrice })
                    ,
                    "Name taken or not valid"
                )
            })

            it('does not accept positions of more than 32 characters', async function () {
                this.token.getCard(firstToken[0], ['thishasexactlythirtytwocharacter', '', '', '', 0, '', '', ''], { from: buyer1, value: mintPrice })
                await expectRevert(
                    this.token.getCard(secondToken[0], ['thishasmorethanthirtytwocharacter', '', '', '', 0, '', '', ''], { from: buyer1, value: mintPrice })
                    ,
                    "Position not valid"
                )
            })

            it('does not accept reserved names', async function () {
                // Reserving the name first
                this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: mintPrice })
                await expectRevert(
                    this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: mintPrice })
                    ,
                    "Name taken or not valid"
                )
            })

            context('when minting is successful', function () {

                it('reserves the name when minting', async function () {
                    await this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: mintPrice })
                    expect(await this.token.isNameReserved(firstToken[0])).to.be.equal(true)
                })
    
                it('saves the name as given', async function () {
                    await this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: mintPrice })
                    const stats = await this.token.tokenStats('1')
                    expect(stats.name).to.be.equal(firstToken[0])
                    // expect(stats.position).to.be.equal(firstToken[1]) v2: position no longer lives in the smart contract
                })
    
                it('generates an appropriate length digit number for genes', async function () {
                    /* The genes number must be 30 digits in length for the server oracle to work
                     * If it isn't, the server oracle will add leading zeros to generate the appropriate tokenURI
                     * For the sake of testing we assume the case that the genes will be 28-30 digits long, which
                     * ensures that the contract works as expected 
                    */
                    await this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: mintPrice });
                    const stats = await this.token.tokenStats('1');
                    expect(stats.genes.length).to.be.at.most(30);
                    expect(stats.genes.length).to.be.at.least(28);
                })

                it('emits a Transfer event', async function () {
                    tx = await this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: mintPrice })
                    expectEvent(tx, 'Transfer', { from: ZERO_ADDRESS, to: buyer1, tokenId: new BN('1') })
                })

                it('generates a request associated with the tokenId', async function () {
                    await this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: mintPrice })
                    expect(await this.token.requests(1)).to.be.equal(true)
                })

                it('funds the server oracle for updating', async function () {
                    let start_balance = BigInt(await web3.eth.getBalance(oracle))
                    await this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: mintPrice })
                    let end_balance = BigInt(await web3.eth.getBalance(oracle))
                    let balance_gain = end_balance - start_balance
                    
                    // Gain in balance should be equal to the amount of funds being sent to the oracle
                    expect(balance_gain).to.be.equal(BigInt(oraclePrice))
                })

                it('emits a NewRequestEvent', async function () {
                    tx = await this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: mintPrice })
                    expectEvent(tx, 'UpdateRequest', { tokenId: new BN('1'), name: firstToken[0], cardProperties: firstToken[1] });
                })
            })
        })

        describe('updateCard', function () {
            beforeEach(async function () {
                // Mints a token to change name and or position of, and performs the update
                await this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: mintPrice })
                await this.token.callback(new BN('1'), oracleCallbackTokenURI, { from: oracle })
            })

            it('cannot update if sale is paused', async function () {
                this.token.pauseSale({ from: owner })
                await expectRevert.unspecified(
                    this.token.updateCard('1', emptyUpdate[0], emptyUpdate[1], { from: buyer1, value: mintPrice })
                )
            })

            it('cannot update non-existing tokens', async function () {
                // Revert message is not "Token does not exist", because the caller cannot be owner or approved for a token that does not exist
                await expectRevert(
                    this.token.updateCard('2', emptyUpdate[0], emptyUpdate[1], { from: owner, value: updatePrice })
                    ,
                    "ERC721: operator query for nonexistent token"
                )
            })

            it('requires caller to be owner or approved', async function () {
                // Approve the token for the approved address and the operator
                await this.token.approve(approved, '1', { from: buyer1 });
                await this.token.setApprovalForAll(operator, true, { from: buyer1 });
                // A call to change name from these should clear
                await this.token.updateCard('1', emptyUpdate[0], emptyUpdate[1], { from: buyer1, value: updatePrice })
                await this.token.callback(new BN('1'), oracleCallbackTokenURI, { from: oracle })
                await this.token.updateCard('1', emptyUpdate[0], emptyUpdate[1], { from: approved, value: updatePrice })
                await this.token.callback(new BN('1'), oracleCallbackTokenURI, { from: oracle })
                await this.token.updateCard('1', emptyUpdate[0], emptyUpdate[1], { from: operator, value: updatePrice })
                await this.token.callback(new BN('1'), oracleCallbackTokenURI, { from: oracle })
                // But a call from a non approved will not
                await expectRevert(
                    this.token.updateCard('1', emptyUpdate[0], emptyUpdate[1], { from: buyer2, value: updatePrice })
                    ,
                    "Caller is not owner nor approved"
                )
            })

            it('new name must be valid or length 0', async function () {
                await expectRevert(
                    this.token.updateCard('1', '~', emptyUpdate[1], { from: buyer1, value: updatePrice })
                    ,
                    "Non valid characters"
                )
                await expectRevert(
                    this.token.updateCard('1', 'hasmorethantwentytwocha', emptyUpdate[1], { from: buyer1, value: updatePrice })
                    ,
                    "Name taken or not valid"
                )
                // But these clear
                await this.token.updateCard('1', 'Paul ALLEN', emptyUpdate[1], { from: buyer1, value: updatePrice })
                await this.token.callback(new BN('1'), oracleCallbackTokenURI, { from: oracle })
                await this.token.updateCard('1', emptyUpdate[0], emptyUpdate[1], { from: buyer1, value: updatePrice })
            })

            it('position must be valid or length 0', async function () {
                await expectRevert(
                    this.token.updateCard('1', emptyUpdate[0], ['~', '', '', '', 0, '', '', ''], { from: buyer1, value: updatePrice })
                    ,
                    "Non valid characters"
                )
                await expectRevert(
                    this.token.updateCard('1', emptyUpdate[0], ['thishasmorethanthirtytwocharacter', '', '', '', 0, '', '', ''], { from: buyer1, value: updatePrice })
                    ,
                    "Position not valid"
                )
                // But these clear
                await this.token.updateCard('1', emptyUpdate[0], ['President', '', '', '', 0, '', '', ''], { from: buyer1, value: updatePrice })  // Finally made it
                await this.token.callback(new BN('1'), oracleCallbackTokenURI, { from: oracle })
                await this.token.updateCard('1', emptyUpdate[0], emptyUpdate[1], { from: buyer1, value: updatePrice })
            })

            it('reverts if new name is taken', async function () {
                this.token.getCard(secondToken[0], secondToken[1], { from: buyer2, value: mintPrice })
                await expectRevert(
                    this.token.updateCard('1', secondToken[0], secondToken[1], { from: buyer1, value: updatePrice })
                    ,
                    "Name taken or not valid"
                )
            })

            it('reverts if new name is old name', async function () {
                await expectRevert(
                    this.token.updateCard('1', firstToken[0], firstToken[1], { from: buyer1, value: updatePrice })
                    ,
                    "Name taken or not valid"
                )
            })

            it('does not update if value is below the price', async function () {
                await expectRevert.unspecified(
                    this.token.updateCard('1', secondToken[0], secondToken[1], { from: buyer1, value: belowUpdatePrice })
                )
            })

            it('changes the token name, reserves it, and dereserves old name', async function () {
                const startStats = await this.token.tokenStats('1')
                await this.token.updateCard('1', secondToken[0], secondToken[1], { from: buyer1, value: updatePrice })
                const stats = await this.token.tokenStats('1')
                // New name is reserved, old name isn't
                expect(await this.token.isNameReserved(secondToken[0])).to.be.equal(true)
                expect(await this.token.isNameReserved(startStats.name)).to.be.equal(false)
                // Token name is changed
                expect(stats.name).to.be.equal(secondToken[0])
                expect(startStats.name).to.be.not.equal(stats.name)
            })

            it('does not change the token name if not specified', async function () {
                const startStats = await this.token.tokenStats('1')
                await this.token.updateCard('1', emptyUpdate[0], emptyUpdate[1], { from: buyer1, value: updatePrice })
                const stats = await this.token.tokenStats('1')
                // Name is still reserved
                expect(await this.token.isNameReserved(startStats.name)).to.be.equal(true)
                // Token name is the same
                expect(stats.name).to.be.equal(firstToken[0])
                expect(startStats.name).to.be.equal(stats.name)
            })

             // V2: token position no longer lives in smart contract
            /* it('changes the token position', async function () {
                const startStats = await this.token.tokenStats('1')
                await this.token.changeNameAndOrPosition('1', secondToken[0], 'President', { from: buyer1, value: updatePrice })
                const stats = await this.token.tokenStats('1')
                // Token position is changed
                expect(stats.position).to.be.equal('President')
                expect(startStats.position).to.be.not.equal(stats.position)
            }) 

            it('does not changes the token position if not specified', async function () {
                const startStats = await this.token.tokenStats('1')
                await this.token.changeNameAndOrPosition('1', '', '', { from: buyer1, value: updatePrice })
                const stats = await this.token.tokenStats('1')
                // Token position is the same
                expect(stats.position).to.be.equal(firstToken[1])
                expect(startStats.position).to.be.equal(stats.position)
            })*/ 

            context('with a successful change', function () {

                it('generates a request associated with the tokenId', async function () {
                    await this.token.updateCard('1', secondToken[0], secondToken[1], { from: buyer1, value: updatePrice })
                    expect(await this.token.requests(1)).to.be.equal(true)
                })
    
                it('funds the server oracle for updating', async function () {
                    let start_balance = BigInt(await web3.eth.getBalance(oracle))
                    await this.token.updateCard('1', secondToken[0], secondToken[1], { from: buyer1, value: updatePrice })
                    let end_balance = BigInt(await web3.eth.getBalance(oracle))
                    let balance_gain = end_balance - start_balance
                    // Gain in balance should be equal to the amount of funds being sent to the oracle
                    expect(balance_gain).to.be.equal(BigInt(oraclePrice))
                })
    
                it('emits an UpdateRequest event', async function () {
                    tx = await this.token.updateCard('1', secondToken[0], secondToken[1], { from: buyer1, value: updatePrice })
                    expectEvent(tx, 'UpdateRequest', { tokenId: '1', name: secondToken[0], cardProperties: secondToken[1] });
                })
            })

            context('with unprocessed request', function () {
                beforeEach(async function () {
                    // Creates a request that does not get filled
                    await this.token.updateTokenURI('1', firstToken[0], firstToken[1], { from: owner })
                })

                it('cannot change name or position', async function () {
                    await expectRevert(
                        this.token.updateCard('1', secondToken[0], secondToken[1], { from: buyer1, value: updatePrice })
                        ,
                        "Update being processed"
                    )
                })
            })
        })

        describe('swapCards', function () {
            beforeEach(async function () {
                // Mints two tokens to change name and or position of, and performs the updates
                await this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: mintPrice })
                await this.token.callback('1', oracleCallbackTokenURI, { from: oracle })
                await this.token.getCard(secondToken[0], secondToken[1], { from: buyer1, value: mintPrice })
                await this.token.callback('2', oracleCallbackTokenURI, { from: oracle })
            })

            it('cannot update if sale is paused', async function () {
                this.token.pauseSale({ from: owner })
                await expectRevert.unspecified(
                    this.token.swapCards('1', '2', { from: buyer1, value: updatePrice })
                )
            })

            it('cannot update non-existing tokens', async function () {
                // Revert message is not "Token does not exist", because the caller cannot be owner or approved for a token that does not exist
                await expectRevert(
                    this.token.swapCards('1', '3')
                    ,
                    "Caller is not owner nor approved"
                )
            })

            it('requires caller to be owner or approved for both tokens', async function () {
                // Approve the tokens for the approved address and the operator
                await this.token.approve(approved, '1', { from: buyer1 });
                await this.token.approve(approved, '2', { from: buyer1 });
                await this.token.setApprovalForAll(operator, true, { from: buyer1 });
                // A call to swap names from these should clear
                await this.token.swapCards('1', '2', { from: buyer1, value: updatePrice })
                await this.token.callback('1', oracleCallbackTokenURI, { from: oracle })
                await this.token.callback('2', oracleCallbackTokenURI, { from: oracle })
                await this.token.swapCards('1', '2', { from: approved, value: updatePrice })
                await this.token.callback('1', oracleCallbackTokenURI, { from: oracle })
                await this.token.callback('2', oracleCallbackTokenURI, { from: oracle })
                await this.token.swapCards('1', '2', { from: operator, value: updatePrice })
                await this.token.callback('1', oracleCallbackTokenURI, { from: oracle })
                await this.token.callback('2', oracleCallbackTokenURI, { from: oracle })
                // But a call from a non approved will not
                await expectRevert(
                    this.token.swapCards('1', '2', { from: buyer2, value: updatePrice })
                    ,
                    "Caller is not owner nor approved"
                )
            })

            it('does not update if value is below the price', async function () {
                await expectRevert.unspecified(
                    this.token.swapCards('1', '2', { from: buyer1, value: belowUpdatePrice })
                )
            })

            it('swaps the names for both tokens, genes stay the same', async function () {
                const startStats1 = await this.token.tokenStats('1')
                const startStats2 = await this.token.tokenStats('2')
                await this.token.swapCards('1', '2', { from: buyer1, value: updatePrice })
                const stats1 = await this.token.tokenStats('1')
                const stats2 = await this.token.tokenStats('2')
                // Both names are still reserved
                expect(await this.token.isNameReserved(startStats1.name)).to.be.equal(true)
                expect(await this.token.isNameReserved(startStats2.name)).to.be.equal(true)
                // Token names are swapped
                expect(startStats1.name).to.be.equal(stats2.name)
                expect(startStats2.name).to.be.equal(stats1.name)
                // V2: position no longer stored in smart contract
                /* // Token positions are swapped
                expect(startStats1.position).to.be.equal(stats2.position)
                expect(startStats2.position).to.be.equal(stats1.position) */
                // Genes stay the same
                expect(startStats1.genes).to.be.equal(stats1.genes)
                expect(startStats2.genes).to.be.equal(stats2.genes)
            })

            it('reverts if any of the tokens is being processed', async function () {
                // With tokenId1 being processed
                await this.token.updateTokenURI('1', firstToken[0], firstToken[1], { from: owner }) // now token one is being processed
                await expectRevert(
                    this.token.swapCards('1', '2', { from: buyer1, value: updatePrice })
                    ,
                    "Update being processed"
                )
                // With tokenId2 being processed
                await this.token.callback('1', oracleCallbackTokenURI, { from: oracle }) // clear the update request
                await this.token.updateTokenURI('2', secondToken[0], secondToken[1], { from: owner }) // now token two is being processed
                await expectRevert(
                    this.token.swapCards('1', '2', { from: buyer1, value: updatePrice })
                    ,
                    "Update being processed"
                )
                // With both being processed
                await this.token.updateTokenURI('1', firstToken[0], firstToken[1],{ from: owner }) // adds another request -- both tokens being processed now
                await expectRevert(
                    this.token.swapCards('1', '2', { from: buyer1, value: updatePrice })
                    ,
                    "Update being processed"
                )
            })

            context('with a successful swap', async function () {

                it('generates a request associated with the two tokenId', async function () {
                    await this.token.swapCards('1', '2', { from: buyer1, value: updatePrice })
                    expect(await this.token.requests(1)).to.be.equal(true)
                    expect(await this.token.requests(2)).to.be.equal(true)
                })
    
                it('funds the server oracle for updating', async function () {
                    start_balance = BigInt(await web3.eth.getBalance(oracle))
                    await this.token.swapCards('1', '2', { from: buyer1, value: updatePrice })
                    let end_balance = BigInt(await web3.eth.getBalance(oracle))
                    let balance_gain = end_balance - start_balance
                    // Gain in balance should be equal to the amount of funds being sent to the oracle
                    expect(balance_gain).to.be.equal(BigInt(2 * oraclePrice))
                })
    
                it('emits a SwapRequest event', async function () {
                    const stats1 = await this.token.tokenStats('1')
                    const stats2 = await this.token.tokenStats('2')
                    tx = await this.token.swapCards('1', '2', { from: buyer1, value: updatePrice })
                    expectEvent(tx, 'SwapRequest', {tokenId1: '1', tokenId2: '2', genes1: stats1.genes, genes2: stats2.genes})
                })
            })
        })


        describe('updateTokenURI', function () {
            beforeEach(async function () {
                // Mints a new token and updates its URI - so that now an update request can be made
                await this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: mintPrice })
                await this.token.callback(new BN('1'), oracleCallbackTokenURI, { from: oracle })
            })

            it('can be called with sale is paused', async function () {
                this.token.pauseSale({ from: owner })
                this.token.updateTokenURI('1', emptyUpdate[0], emptyUpdate[1], { from: owner })
            })

            it('cannot update non-existing tokens', async function () {
                await expectRevert.unspecified(
                    this.token.updateTokenURI('3', thirdToken[0], thirdToken[1], { from: owner })
                )
            })

            it('cannot be called on a token being processed', async function () {
                await this.token.getCard(secondToken[0], secondToken[1], { from: buyer1, value: mintPrice })
                await expectRevert(
                    this.token.updateTokenURI('2', secondToken[0], secondToken[1], { from: owner })
                    ,
                    "Update being processed"
                )
            })

            it('generates an update request', async function () {
                await this.token.updateTokenURI('1', firstToken[0], firstToken[1], { from: owner })
                expect(await this.token.requests('1')).to.be.true
            })

            it('emits an UpdateRequest event', async function () {
                tx = await this.token.updateTokenURI('1', firstToken[0], firstToken[1], { from: owner })
                expectEvent(tx, 'UpdateRequest', { tokenId: new BN('1'), name: firstToken[0], cardProperties: firstToken[1] });
            })

            it('funds the server oracle for updating', async function () {
                let start_balance = BigInt(await web3.eth.getBalance(oracle))
                await this.token.updateTokenURI('1', firstToken[0], firstToken[1], { from: owner })
                let end_balance = BigInt(await web3.eth.getBalance(oracle))
                let balance_gain = end_balance - start_balance
                // Gain in balance should be equal to the amount of funds being sent to the oracle
                expect(balance_gain).to.be.equal(BigInt(oraclePrice))
            })

            it('tokenURI can be changed and updated', async function () {
                // Previous made callback was successful
                let previousURI = await this.token.tokenURI('1')
                expect(previousURI).to.be.equal(baseURI + oracleCallbackTokenURI)
                // New callback changes the tokenURI
                await this.token.updateTokenURI('1', firstToken[0], firstToken[1], { from: owner })
                await this.token.callback(new BN('1'), altOracleCallbackTokenURI, { from: oracle })
                let newURI = await this.token.tokenURI('1')
                expect(previousURI).to.not.be.equal(newURI)
                expect(newURI).to.be.equal(baseURI + altOracleCallbackTokenURI)
            })
        })


        describe('tokenURI', function () {
            it('cannot be called on a token that does not exist', async function () {
                await expectRevert(
                    this.token.tokenURI(new BN('1'))
                    ,
                    "ERC721Metadata: URI query for nonexistent token"
                )
            })

            context('with a minted token', function () {
                beforeEach(async function () {
                    await this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: mintPrice});
                })

                it('returns base + default if not updated by oracle', async function () {
                    expect(await this.token.requests(new BN('1'))).to.be.true;
                    expect(await this.token.tokenURI(new BN('1'))).to.be.equal(baseURI + defaultURI);
                })

                it('returns base + corresponding tokenURI if updated', async function () {
                    await this.token.callback(new BN('1'), oracleCallbackTokenURI, { from: oracle })
                    expect(await this.token.requests(new BN('1'))).to.be.false;
                    expect(await this.token.tokenURI(new BN('1'))).to.be.equal(baseURI + oracleCallbackTokenURI);
                })
            })
        })


        describe('baseURI', function () {
            it('returns the one defined at deployment', async function () {
                expect(await this.token.baseURI()).to.be.equal(baseURI)
            })

            it('cannot be changed by non owner', async function () {
                await expectRevert(
                    this.token.setBaseURI(altBaseURI, { from: buyer1 })
                    ,
                    "Ownable: caller is not the owner"
                )
            })

            it('cannot be changed to empty string', async function () {
                await expectRevert.unspecified(
                    this.token.setBaseURI('')
                )
            })

            it('reflects the change', async function () {
                await this.token.setBaseURI(altBaseURI, { from: owner })
                expect(await this.token.baseURI()).to.be.equal(altBaseURI)
            })
        })


        describe('defaultURI', function () {
            it('returns the one defined at deployment', async function () {
                expect(await this.token.defaultURI()).to.be.equal(defaultURI)
            })

            it('cannot be changed by non owner', async function () {
                await expectRevert(
                    this.token.setDefaultURI(altDefaultURI, { from: buyer1 })
                    ,
                    "Ownable: caller is not the owner"
                )
            })

            it('cannot be changed to empty string', async function () {
                await expectRevert.unspecified(
                    this.token.setDefaultURI('')
                )
            })

            it('reflects the change', async function () {
                await this.token.setDefaultURI(altDefaultURI, { from: owner })
                expect(await this.token.defaultURI()).to.be.equal(altDefaultURI)
            })
        })


        describe('pauseSale', function () {
            it('cannot be paused by non owner', async function () {
                await expectRevert(
                    this.token.pauseSale({ from: buyer1 })
                    ,
                    "Ownable: caller is not the owner"
                )
            })

            context('with sale paused', function () {
                beforeEach(async function () {
                    // minting and updating a card first for following tests
                    await this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: mintPrice })
                    await this.token.callback(new BN('1'), oracleCallbackTokenURI, { from: oracle })
                    // pausing sale
                    await this.token.pauseSale({ from: owner })
                })

                it('cannot mint new tokens', async function () {
                    await expectRevert.unspecified(
                        this.token.getCard(secondToken[0], secondToken[1], { from: buyer2, value: mintPrice})
                    )
                })

                it('can start sale again', async function () {
                    await this.token.startSale({ from: owner })
                })

                it('can mint new tokens after unpaused', async function () {
                    await this.token.startSale({ from: owner })
                    await this.token.getCard(secondToken[0], secondToken[1], { from: buyer2, value: mintPrice})
                })

                it('can update tokens after unpaused', async function () {
                    await this.token.startSale({ from: owner })
                    await this.token.updateTokenURI('1', firstToken[0], firstToken[1], { from: owner })
                })
            })
        })


        describe('isNameReserved', function () {
            it('returns false on non-minted names', async function () {
                expect(await this.token.isNameReserved(firstToken[0])).to.be.false;
            })

            it('returns true on minted names', async function () {
                await this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: mintPrice});
                expect(await this.token.isNameReserved(firstToken[0])).to.be.true;
            })
        })


        
        describe('withdraw', function () {
            beforeEach(async function () {
                // getting a card to fund the contract
                await this.token.getCard(firstToken[0], firstToken[1], { from: buyer1, value: mintPrice })
            })

            it('cannot be called by non owner', async function () {
                await expectRevert(
                    this.token.withdraw({ from: buyer1 })
                    ,
                    "Ownable: caller is not the owner"
                )
            })

            it('holds funds in the contract', async function() {
                // Value held in the contract will be equal to the mint price minus the oracle price
                // When minting a card, the Business Card automatically funds the server oracle to update the cards
                expect(parseInt(await web3.eth.getBalance(await this.token.address))).to.be.equal(mintPrice - oraclePrice)
            })  

            it('can withdraw all the funds to owner', async function () {
                const startBalance = BigInt(await web3.eth.getBalance(owner))

                // Calling the withdrawal function as the owner costs gas and results in a balance gain, emptying the Card contract funds
                const contractBalance = BigInt(await web3.eth.getBalance(this.token.address))
                const txDict = await this.token.withdraw({ from: owner })

                // Transaction fee paid for withdrawing funds
                const gasUsed = BigInt(txDict.receipt.gasUsed.toString())
                const effectiveGasPrice = BigInt(txDict.receipt.effectiveGasPrice.toString()) 
                const txFee = gasUsed * effectiveGasPrice

                // Owners end balance after withdrawing funds
                const endBalance = BigInt(await web3.eth.getBalance(owner))

                const balanceGain = endBalance - startBalance  // Actual recorded balance gain
                const expectedAmount = contractBalance - txFee  // Expected balance gain, withdrawing what was in the contract minus the txFee
                
                const newContractBalance = await web3.eth.getBalance(this.token.address)

                expect(newContractBalance).to.be.equal('0')  // Contract balance is empty
                expect(balanceGain).to.be.equal(expectedAmount)  // Owner got it all
            })
        })
    })
}

module.exports = {
    shouldBehaveLikeBusinessCard,
}